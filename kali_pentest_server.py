#!/usr/bin/env python3
"""Kali Linux Penetration Testing MCP Server - Comprehensive security testing tools for educational purposes and authorized assessments"""
import os
import sys
import logging
import subprocess
import shlex
from mcp.server.fastmcp import FastMCP

# Configure logging to stderr only
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    stream=sys.stderr
)
logger = logging.getLogger("kali-pentest-mcp")

# Initialize MCP server
mcp = FastMCP("kali-pentest-tools")

# Configuration
MAX_OUTPUT_LINES = 200
TIMEOUT_SHORT = 60        # 1 minute - Quick lookups
TIMEOUT_MEDIUM = 300      # 5 minutes - Moderate scans
TIMEOUT_LONG = 600        # 10 minutes - Heavy scans
TIMEOUT_EXTRA_LONG = 1800 # 30 minutes - Comprehensive vulnerability scans

# === UTILITY FUNCTIONS ===

def sanitize_input(value: str) -> str:
    """Sanitize user input using shlex.quote for safe command execution."""
    if not value or not value.strip():
        return ""
    return shlex.quote(value.strip())

def run_command(cmd_list, timeout: int = TIMEOUT_MEDIUM) -> str:
    """Execute a command safely with proper error handling and output formatting."""
    try:
        logger.info(f"Executing command: {' '.join(cmd_list[:5])}...")
        
        result = subprocess.run(
            cmd_list,
            capture_output=True,
            text=True,
            timeout=timeout
        )
        
        # Combine stdout and stderr
        output = result.stdout + result.stderr
        
        # Limit output length to prevent overwhelming responses
        lines = output.split('\n')
        if len(lines) > MAX_OUTPUT_LINES:
            output = '\n'.join(lines[:MAX_OUTPUT_LINES])
            output += f"\n\n... (truncated {len(lines) - MAX_OUTPUT_LINES} additional lines)"
        
        if result.returncode == 0:
            return f"âœ… Scan completed successfully:\n\n{output}" if output.strip() else "âœ… Command completed successfully (no output)"
        else:
            return f"âš ï¸ Scan completed with warnings:\n\n{output}" if output.strip() else f"âš ï¸ Command returned exit code {result.returncode}"
            
    except subprocess.TimeoutExpired:
        return f"â±ï¸ Command timed out after {timeout} seconds. Try reducing scan scope or increasing timeout."
    except FileNotFoundError as e:
        return f"âŒ Error: Command not found. Tool may not be installed: {str(e)}"
    except Exception as e:
        logger.error(f"Command execution error: {e}")
        return f"âŒ Error executing command: {str(e)}"

def validate_target(target: str) -> str:
    """Validate and return cleaned target or empty string if invalid."""
    if not target or not target.strip():
        return ""
    cleaned = target.strip()
    if len(cleaned) > 500:
        return ""
    return cleaned

# === NETWORK RECONNAISSANCE & SCANNING ===

@mcp.tool()
async def nmap_scan(target: str = "", ports: str = "") -> str:
    """Perform basic TCP connect scan with nmap on specified target - uses -Pn flag for Docker MCP compatibility."""
    target = validate_target(target)
    if not target:
        return "âŒ Error: Valid target IP address or hostname required"
    
    cmd = ["nmap", "-sT", "-Pn"]
    if ports and ports.strip():
        cmd.extend(["-p", ports.strip()])
    else:
        cmd.append("-F")  # Fast scan only if no specific ports specified
    cmd.append(target)
    
    return run_command(cmd, timeout=TIMEOUT_LONG)

@mcp.tool()
async def nmap_service_scan(target: str = "", ports: str = "") -> str:
    """Perform service version detection scan with nmap - identifies running services and versions."""
    target = validate_target(target)
    if not target:
        return "âŒ Error: Valid target IP address or hostname required"
    
    cmd = ["nmap", "-sT", "-Pn", "-sV"]
    if ports and ports.strip():
        cmd.extend(["-p", ports.strip()])
    else:
        cmd.append("--top-ports=100")
    cmd.append(target)
    
    return run_command(cmd, timeout=TIMEOUT_LONG)

@mcp.tool()
async def nmap_vuln_scan(target: str = "") -> str:
    """Perform vulnerability scanning with nmap using vuln scripts - detects known vulnerabilities."""
    target = validate_target(target)
    if not target:
        return "âŒ Error: Valid target IP address or hostname required"
    
    # Scope limited to top 20 ports to prevent timeout (use --top-ports=100 for comprehensive scan)
    cmd = ["nmap", "-sT", "-Pn", "-sV", "--script=vuln", "--top-ports=20", target]
    return run_command(cmd, timeout=TIMEOUT_EXTRA_LONG)

@mcp.tool()
async def nmap_comprehensive_scan(target: str = "", ports: str = "") -> str:
    """Comprehensive scan with service detection and NSE scripts - combines -sV and -sC for detailed enumeration."""
    target = validate_target(target)
    if not target:
        return "âŒ Error: Valid target IP address or hostname required"
    
    # -sV: Service version detection
    # -sC: Default NSE scripts (banner grabbing, SSL cert info, HTTP headers, etc.)
    cmd = ["nmap", "-sT", "-Pn", "-sV", "-sC"]
    
    if ports and ports.strip():
        cmd.extend(["-p", ports.strip()])
    else:
        cmd.append("--top-ports=100")
    
    cmd.append(target)
    return run_command(cmd, timeout=TIMEOUT_EXTRA_LONG)

@mcp.tool()
async def nmap_port_scan(target: str = "", ports: str = "") -> str:
    """Scan specific ports with nmap - allows custom port specification (e.g., '22,80,443' or '1-1000' or '1-65535')."""
    target = validate_target(target)
    if not target:
        return "âŒ Error: Valid target IP address or hostname required"
    
    if not ports or not ports.strip():
        return "âŒ Error: Port specification required (e.g., '22,80,443' or '1-1000' or '1-65535')"
    
    cmd = ["nmap", "-sT", "-Pn", "-p", ports.strip(), target]
    return run_command(cmd, timeout=TIMEOUT_LONG)

@mcp.tool()
async def nmap_script_scan(target: str = "", scripts: str = "default", ports: str = "") -> str:
    """Run specific NSE script categories against target - options: default, safe, discovery, auth, vuln, exploit, broadcast, intrusive, malware. Multiple categories can be comma-separated."""
    target = validate_target(target)
    if not target:
        return "âŒ Error: Valid target IP address or hostname required"
    
    # Validate script category (allow comma-separated list)
    script_cat = scripts.strip() if scripts.strip() else "default"
    
    # Service detection helps NSE scripts work better
    cmd = ["nmap", "-sT", "-Pn", "-sV", f"--script={script_cat}"]
    
    if ports and ports.strip():
        cmd.extend(["-p", ports.strip()])
    else:
        cmd.append("--top-ports=50")
    
    cmd.append(target)
    return run_command(cmd, timeout=TIMEOUT_EXTRA_LONG)

@mcp.tool()
async def dns_enum(domain: str = "") -> str:
    """Perform DNS enumeration using standard DNS tools - nslookup, dig, and host commands."""
    domain = validate_target(domain)
    if not domain:
        return "âŒ Error: Valid domain name required"
    
    domain_safe = sanitize_input(domain)
    results = []
    
    # nslookup
    results.append("=== NSLOOKUP ===")
    result1 = run_command(["nslookup", domain], timeout=TIMEOUT_SHORT)
    results.append(result1)
    
    # dig
    results.append("\n=== DIG ANY ===")
    result2 = run_command(["dig", domain, "ANY"], timeout=TIMEOUT_SHORT)
    results.append(result2)
    
    # host
    results.append("\n=== HOST ===")
    result3 = run_command(["host", "-a", domain], timeout=TIMEOUT_SHORT)
    results.append(result3)
    
    return "\n".join(results)

@mcp.tool()
async def dns_recon(domain: str = "") -> str:
    """Perform advanced DNS reconnaissance with dnsrecon tool - discovers subdomains and DNS records."""
    domain = validate_target(domain)
    if not domain:
        return "âŒ Error: Valid domain name required"
    
    cmd = ["dnsrecon", "-d", domain]
    return run_command(cmd, timeout=TIMEOUT_MEDIUM)

@mcp.tool()
async def subfinder_scan(domain: str = "") -> str:
    """Fast subdomain discovery using subfinder - queries multiple data sources for subdomains."""
    domain = validate_target(domain)
    if not domain:
        return "âŒ Error: Valid domain name required"
    
    cmd = ["subfinder", "-d", domain, "-silent"]
    return run_command(cmd, timeout=TIMEOUT_MEDIUM)

@mcp.tool()
async def amass_enum(domain: str = "", mode: str = "passive") -> str:
    """Comprehensive DNS enumeration with OWASP Amass - mode options: passive or active."""
    domain = validate_target(domain)
    if not domain:
        return "âŒ Error: Valid domain name required"
    
    if mode.strip().lower() == "active":
        cmd = ["amass", "enum", "-active", "-d", domain]
    else:
        cmd = ["amass", "enum", "-passive", "-d", domain]
    
    return run_command(cmd, timeout=TIMEOUT_LONG)

@mcp.tool()
async def fierce_scan(domain: str = "") -> str:
    """DNS reconnaissance with fierce - attempts zone transfer and brute-forces subdomains."""
    domain = validate_target(domain)
    if not domain:
        return "âŒ Error: Valid domain name required"
    
    cmd = ["fierce", "--domain", domain]
    return run_command(cmd, timeout=TIMEOUT_MEDIUM)

# === WEB APPLICATION TESTING ===

@mcp.tool()
async def nikto_scan(target: str = "", port: str = "80") -> str:
    """Perform comprehensive web server vulnerability scanning with nikto."""
    target = validate_target(target)
    if not target:
        return "âŒ Error: Valid target URL or IP address required"
    
    port_clean = port.strip() if port.strip() else "80"
    # Scope limited to critical tests only (Tuning 1,2,3) to prevent timeout
    cmd = ["nikto", "-h", f"{target}:{port_clean}", "-nointeractive", "-Tuning", "123"]
    
    return run_command(cmd, timeout=TIMEOUT_EXTRA_LONG)

@mcp.tool()
async def wpscan_scan(target: str = "", enumerate: str = "vp") -> str:
    """Scan WordPress sites for vulnerabilities - enumerate options: vp (plugins), vt (themes), u (users), ap (all plugins)."""
    target = validate_target(target)
    if not target:
        return "âŒ Error: Valid WordPress URL required"
    
    if not target.startswith("http://") and not target.startswith("https://"):
        target = f"http://{target}"
    
    enum_opts = ["vp", "vt", "u", "ap", "at", "cb", "dbe"]
    enum_clean = enumerate.strip() if enumerate.strip() in enum_opts else "vp"
    
    # Scope limited: only popular plugins, max 10 threads to prevent timeout
    cmd = ["wpscan", "--url", target, "--enumerate", enum_clean, "--random-user-agent", "--no-banner", "--plugins-detection", "popular", "--max-threads", "10"]
    return run_command(cmd, timeout=TIMEOUT_EXTRA_LONG)

@mcp.tool()
async def dirb_scan(target: str = "", wordlist: str = "common") -> str:
    """Perform directory brute-forcing with dirb - wordlist options: common, big, small."""
    target = validate_target(target)
    if not target:
        return "âŒ Error: Valid URL required"
    
    if not target.startswith("http://") and not target.startswith("https://"):
        target = f"http://{target}"
    
    wordlist_map = {
        "common": "/usr/share/dirb/wordlists/common.txt",
        "big": "/usr/share/dirb/wordlists/big.txt",
        "small": "/usr/share/dirb/wordlists/small.txt"
    }
    
    wordlist_path = wordlist_map.get(wordlist.strip().lower(), wordlist_map["common"])
    cmd = ["dirb", target, wordlist_path, "-S", "-r"]
    
    return run_command(cmd, timeout=TIMEOUT_LONG)

@mcp.tool()
async def ffuf_scan(target: str = "", wordlist: str = "", extensions: str = "") -> str:
    """Fast web fuzzing with ffuf - target must contain FUZZ keyword as placeholder."""
    target = validate_target(target)
    if not target or "FUZZ" not in target:
        return "âŒ Error: Valid URL with FUZZ placeholder required (e.g., http://example.com/FUZZ)"
    
    wordlist_path = wordlist.strip() if wordlist.strip() else "/usr/share/wordlists/dirb/common.txt"
    cmd = ["ffuf", "-u", target, "-w", wordlist_path, "-mc", "200,204,301,302,307,401,403", "-t", "40"]
    
    if extensions and extensions.strip():
        cmd.extend(["-e", extensions.strip()])
    
    return run_command(cmd, timeout=TIMEOUT_LONG)

@mcp.tool()
async def gobuster_scan(target: str = "", wordlist: str = "", mode: str = "dir") -> str:
    """High-speed directory and DNS brute-forcing with gobuster - mode options: dir, dns, vhost."""
    target = validate_target(target)
    if not target:
        return "âŒ Error: Valid target required"
    
    wordlist_path = wordlist.strip() if wordlist.strip() else "/usr/share/wordlists/dirb/common.txt"
    mode_clean = mode.strip().lower()
    
    if mode_clean == "dns":
        cmd = ["gobuster", "dns", "-d", target, "-w", wordlist_path]
    elif mode_clean == "vhost":
        if not target.startswith("http"):
            target = f"http://{target}"
        cmd = ["gobuster", "vhost", "-u", target, "-w", wordlist_path]
    else:
        if not target.startswith("http"):
            target = f"http://{target}"
        cmd = ["gobuster", "dir", "-u", target, "-w", wordlist_path]
    
    return run_command(cmd, timeout=TIMEOUT_LONG)

@mcp.tool()
async def wfuzz_scan(target: str = "", wordlist: str = "", hide_code: str = "") -> str:
    """Advanced web application fuzzing with wfuzz - target must contain FUZZ keyword as placeholder."""
    target = validate_target(target)
    if not target or "FUZZ" not in target:
        return "âŒ Error: Valid URL with FUZZ placeholder required"
    
    wordlist_path = wordlist.strip() if wordlist.strip() else "/usr/share/wordlists/dirb/common.txt"
    cmd = ["wfuzz", "-w", wordlist_path]
    
    if hide_code and hide_code.strip():
        cmd.extend(["--hc", hide_code.strip()])
    
    cmd.append(target)
    return run_command(cmd, timeout=TIMEOUT_LONG)

@mcp.tool()
async def sqlmap_scan(target: str = "", data: str = "", parameter: str = "") -> str:
    """Test for SQL injection vulnerabilities with sqlmap - provide URL and optional POST data or specific parameter."""
    target = validate_target(target)
    if not target:
        return "âŒ Error: Valid URL required"
    
    if not target.startswith("http://") and not target.startswith("https://"):
        return "âŒ Error: Target must be a full URL (http:// or https://)"
    
    # Scope limited: risk=1, level=1, no extensive WAF testing, threads=5 to prevent timeout
    cmd = ["sqlmap", "-u", target, "--batch", "--risk=1", "--level=1", "--random-agent", "--threads=5", "--technique=BEUST"]
    
    if data and data.strip():
        cmd.extend(["--data", data.strip()])
    
    if parameter and parameter.strip():
        cmd.extend(["-p", parameter.strip()])
    
    return run_command(cmd, timeout=TIMEOUT_EXTRA_LONG)

@mcp.tool()
async def whatweb_scan(target: str = "", aggression: str = "1") -> str:
    """Web technology fingerprinting with whatweb - aggression levels: 1 (stealthy) to 4 (aggressive)."""
    target = validate_target(target)
    if not target:
        return "âŒ Error: Valid URL or domain required"
    
    if not target.startswith("http"):
        target = f"http://{target}"
    
    agg_level = aggression.strip() if aggression.strip() in ["1", "2", "3", "4"] else "1"
    cmd = ["whatweb", "-a", agg_level, target]
    
    return run_command(cmd, timeout=TIMEOUT_MEDIUM)

@mcp.tool()
async def wafw00f_scan(target: str = "") -> str:
    """Identify Web Application Firewall (WAF) protecting a website."""
    target = validate_target(target)
    if not target:
        return "âŒ Error: Valid URL required"
    
    if not target.startswith("http"):
        target = f"http://{target}"
    
    cmd = ["wafw00f", target]
    return run_command(cmd, timeout=TIMEOUT_MEDIUM)

@mcp.tool()
async def nuclei_scan(target: str = "", templates: str = "", severity: str = "") -> str:
    """Template-based vulnerability scanning with nuclei - severity options: critical, high, medium, low, info."""
    target = validate_target(target)
    if not target:
        return "âŒ Error: Valid target URL required"
    
    if not target.startswith("http"):
        target = f"http://{target}"
    
    cmd = ["nuclei", "-u", target]
    
    if templates and templates.strip():
        cmd.extend(["-t", templates.strip()])
    
    # Default to critical+high severity only if not specified to prevent timeout
    if severity and severity.strip():
        cmd.extend(["-s", severity.strip()])
    else:
        cmd.extend(["-s", "critical,high"])
    
    # Rate limit to prevent timeout
    cmd.extend(["-rl", "150"])
    
    return run_command(cmd, timeout=TIMEOUT_EXTRA_LONG)

@mcp.tool()
async def web_headers(target: str = "") -> str:
    """Retrieve and analyze HTTP headers from target web server using curl."""
    target = validate_target(target)
    if not target:
        return "âŒ Error: Valid URL required"
    
    if not target.startswith("http"):
        target = f"http://{target}"
    
    # -sS: Silent mode with errors shown (suppresses progress bar)
    cmd = ["curl", "-I", "-L", "-sS", "--max-time", "30", target]
    return run_command(cmd, timeout=TIMEOUT_SHORT)

# === SSL/TLS TESTING ===

@mcp.tool()
async def sslscan_scan(target: str = "", port: str = "443") -> str:
    """Test SSL/TLS cipher suites and protocols with sslscan."""
    target = validate_target(target)
    if not target:
        return "âŒ Error: Valid target hostname required"
    
    port_clean = port.strip() if port.strip() else "443"
    cmd = ["sslscan", f"{target}:{port_clean}"]
    
    return run_command(cmd, timeout=TIMEOUT_MEDIUM)

@mcp.tool()
async def testssl_scan(target: str = "", port: str = "443") -> str:
    """Comprehensive SSL/TLS vulnerability assessment with testssl.sh."""
    target = validate_target(target)
    if not target:
        return "âŒ Error: Valid target hostname required"
    
    port_clean = port.strip() if port.strip() else "443"
    # --fast mode with --severity HIGH to focus on critical issues and prevent timeout
    cmd = ["testssl", "--fast", "--severity", "HIGH", f"{target}:{port_clean}"]
    
    return run_command(cmd, timeout=TIMEOUT_EXTRA_LONG)

@mcp.tool()
async def sslyze_scan(target: str = "", port: str = "443") -> str:
    """Fast SSL/TLS configuration analysis with sslyze."""
    target = validate_target(target)
    if not target:
        return "âŒ Error: Valid target hostname required"
    
    port_clean = port.strip() if port.strip() else "443"
    cmd = ["sslyze", f"{target}:{port_clean}"]
    
    return run_command(cmd, timeout=TIMEOUT_MEDIUM)

# === SMB & WINDOWS ENUMERATION ===

@mcp.tool()
async def enum4linux_scan(target: str = "") -> str:
    """Enumerate SMB/CIFS shares, users, and groups with enum4linux."""
    target = validate_target(target)
    if not target:
        return "âŒ Error: Valid target IP or hostname required"
    
    # Scope limited: basic enumeration (-U users, -S shares, -G groups) instead of -a (all) to prevent timeout
    cmd = ["enum4linux", "-U", "-S", "-G", target]
    return run_command(cmd, timeout=TIMEOUT_EXTRA_LONG)

@mcp.tool()
async def nbtscan_scan(target: str = "") -> str:
    """Scan NetBIOS nameservers in specified IP range or single host."""
    target = validate_target(target)
    if not target:
        return "âŒ Error: Valid IP address or range required (e.g., 192.168.1.0/24)"
    
    cmd = ["nbtscan", target]
    return run_command(cmd, timeout=TIMEOUT_MEDIUM)

@mcp.tool()
async def crackmapexec_scan(target: str = "", protocol: str = "smb") -> str:
    """Enumerate Windows/Active Directory networks with crackmapexec - protocol options: smb, winrm, ldap, mssql."""
    target = validate_target(target)
    if not target:
        return "âŒ Error: Valid target IP or hostname required"
    
    proto_opts = ["smb", "winrm", "ldap", "mssql", "ssh", "ftp"]
    proto_clean = protocol.strip().lower() if protocol.strip().lower() in proto_opts else "smb"
    
    cmd = ["crackmapexec", proto_clean, target]
    return run_command(cmd, timeout=TIMEOUT_MEDIUM)

@mcp.tool()
async def responder_analyze(interface: str = "") -> str:
    """Information about Responder tool for LLMNR/NBT-NS/mDNS poisoning - requires elevated privileges."""
    return "âš ï¸ Responder is a credential capture tool that requires elevated privileges and active network poisoning.\n\nTo use Responder manually:\n1. Run with sudo: sudo responder -I <interface>\n2. Add -A flag for passive analysis mode: sudo responder -I <interface> -A\n3. Captured credentials stored in /usr/share/responder/logs/\n\nâš ï¸ WARNING: Only use Responder on networks you are authorized to test. LLMNR/NBT-NS poisoning can disrupt network operations."

@mcp.tool()
async def smb_enum(target: str = "") -> str:
    """Enumerate SMB shares using smbclient - lists available shares on target."""
    target = validate_target(target)
    if not target:
        return "âŒ Error: Valid target IP or hostname required"
    
    cmd = ["smbclient", "-L", target, "-N"]
    return run_command(cmd, timeout=TIMEOUT_MEDIUM)

# === PASSWORD & CREDENTIAL TESTING ===

@mcp.tool()
async def hydra_attack(target: str = "", service: str = "ssh", username: str = "", password_list: str = "") -> str:
    """Network service password brute-forcing with hydra - service options: ssh, ftp, http-get, http-post, rdp, smb."""
    target = validate_target(target)
    if not target:
        return "âŒ Error: Valid target IP or hostname required"
    
    if not username or not username.strip():
        return "âŒ Error: Username required for password brute-forcing"
    
    service_clean = service.strip() if service.strip() else "ssh"
    pass_list = password_list.strip() if password_list.strip() else "/usr/share/wordlists/rockyou.txt"
    
    if not os.path.exists(pass_list):
        pass_list = "/usr/share/wordlists/dirb/common.txt"
    
    cmd = ["hydra", "-l", username.strip(), "-P", pass_list, target, service_clean, "-t", "4"]
    return run_command(cmd, timeout=TIMEOUT_LONG)

@mcp.tool()
async def john_crack(hash_file: str = "", format: str = "") -> str:
    """Crack password hashes with John the Ripper - format examples: raw-md5, raw-sha1, bcrypt, descrypt, NT."""
    hash_file_clean = validate_target(hash_file)
    if not hash_file_clean:
        return "âŒ Error: Hash file path required"
    
    if not os.path.exists(hash_file_clean):
        return f"âŒ Error: Hash file not found: {hash_file_clean}"
    
    cmd = ["john", hash_file_clean]
    
    if format and format.strip():
        cmd.extend(["--format=" + format.strip()])
    
    return run_command(cmd, timeout=TIMEOUT_LONG)

@mcp.tool()
async def hashcat_crack(hash_file: str = "", mode: str = "0", wordlist: str = "") -> str:
    """Advanced password cracking with hashcat - NOTE: CPU-only mode on ARM64, no GPU acceleration available. Mode examples: 0 (MD5), 100 (SHA1), 1000 (NTLM), 3200 (bcrypt)."""
    hash_file_clean = validate_target(hash_file)
    if not hash_file_clean:
        return "âŒ Error: Hash file path required"
    
    if not os.path.exists(hash_file_clean):
        return f"âŒ Error: Hash file not found: {hash_file_clean}"
    
    mode_clean = mode.strip() if mode.strip() else "0"
    wlist = wordlist.strip() if wordlist.strip() else "/usr/share/wordlists/rockyou.txt"
    
    if not os.path.exists(wlist):
        wlist = "/usr/share/wordlists/dirb/common.txt"
    
    cmd = ["hashcat", "-m", mode_clean, "-a", "0", hash_file_clean, wlist, "--force"]
    return run_command(cmd, timeout=TIMEOUT_LONG)

# === VULNERABILITY RESEARCH & EXPLOITATION ===

@mcp.tool()
async def searchsploit_search(query: str = "") -> str:
    """Search exploit database for known vulnerabilities using searchsploit."""
    query_clean = validate_target(query)
    if not query_clean:
        return "âŒ Error: Search query required"
    
    cmd = ["searchsploit", query_clean]
    return run_command(cmd, timeout=TIMEOUT_SHORT)

@mcp.tool()
async def metasploit_search(query: str = "") -> str:
    """Search Metasploit Framework modules for exploits and auxiliary tools - NOTE: Some modules may not work on ARM64."""
    query_clean = validate_target(query)
    if not query_clean:
        return "âŒ Error: Search query required"
    
    cmd = ["msfconsole", "-q", "-x", f"search {query_clean}; exit"]
    return run_command(cmd, timeout=TIMEOUT_MEDIUM)

@mcp.tool()
async def metasploit_info(module: str = "") -> str:
    """Get detailed information about a specific Metasploit module."""
    module_clean = validate_target(module)
    if not module_clean:
        return "âŒ Error: Module path required (e.g., exploit/windows/smb/ms17_010_eternalblue)"
    
    cmd = ["msfconsole", "-q", "-x", f"info {module_clean}; exit"]
    return run_command(cmd, timeout=TIMEOUT_MEDIUM)

# === OSINT & INFORMATION GATHERING ===

@mcp.tool()
async def theharvester_scan(domain: str = "", source: str = "all") -> str:
    """Gather emails, subdomains, and hosts from public sources - source options: all, google, bing, linkedin, twitter, duckduckgo."""
    domain = validate_target(domain)
    if not domain:
        return "âŒ Error: Valid domain required"
    
    source_opts = ["all", "google", "bing", "linkedin", "twitter", "duckduckgo", "yahoo", "baidu"]
    source_clean = source.strip().lower() if source.strip().lower() in source_opts else "all"
    
    # Scope limited: 50 results (instead of 100) and default to 'google' if 'all' to prevent timeout
    if source_clean == "all":
        source_clean = "google"
    cmd = ["theHarvester", "-d", domain, "-b", source_clean, "-l", "50"]
    return run_command(cmd, timeout=TIMEOUT_EXTRA_LONG)

@mcp.tool()
async def whois_lookup(domain: str = "") -> str:
    """Domain registration and ownership information lookup using whois."""
    domain = validate_target(domain)
    if not domain:
        return "âŒ Error: Valid domain required"
    
    cmd = ["whois", domain]
    return run_command(cmd, timeout=TIMEOUT_SHORT)

# === COMBINED OPERATIONS ===

@mcp.tool()
async def quick_recon(target: str = "") -> str:
    """Fast reconnaissance combining nmap, whatweb, and basic SSL checks - ideal for initial target assessment."""
    target = validate_target(target)
    if not target:
        return "âŒ Error: Valid target IP, domain, or URL required"
    
    results = []
    results.append("=" * 60)
    results.append("ğŸ” QUICK RECONNAISSANCE REPORT")
    results.append("=" * 60)
    
    # Nmap quick scan
    results.append("\nğŸ“¡ NMAP QUICK SCAN (Top 100 Ports):")
    results.append("-" * 60)
    nmap_result = await nmap_scan(target)
    results.append(nmap_result)
    
    # Web fingerprinting
    results.append("\nğŸŒ WEB TECHNOLOGY FINGERPRINTING:")
    results.append("-" * 60)
    whatweb_result = await whatweb_scan(target, "1")
    results.append(whatweb_result)
    
    # WHOIS lookup for domains
    if "." in target and not target.replace(".", "").replace("/", "").isdigit():
        results.append("\nğŸ“‹ WHOIS INFORMATION:")
        results.append("-" * 60)
        whois_result = await whois_lookup(target)
        results.append(whois_result)
    
    results.append("\n" + "=" * 60)
    results.append("âœ… Quick reconnaissance completed")
    results.append("=" * 60)
    
    return "\n".join(results)

@mcp.tool()
async def full_recon(target: str = "") -> str:
    """Comprehensive reconnaissance with multiple tools - WARNING: This operation takes significant time and generates extensive output."""
    target = validate_target(target)
    if not target:
        return "âŒ Error: Valid target IP, domain, or URL required"
    
    results = []
    results.append("=" * 60)
    results.append("ğŸ” COMPREHENSIVE RECONNAISSANCE REPORT")
    results.append("=" * 60)
    
    # Service scan
    results.append("\nğŸ“¡ NMAP SERVICE VERSION DETECTION:")
    results.append("-" * 60)
    nmap_result = await nmap_service_scan(target)
    results.append(nmap_result)
    
    # DNS enumeration for domains
    if "." in target and not target.replace(".", "").replace("/", "").isdigit():
        results.append("\nğŸŒ DNS ENUMERATION:")
        results.append("-" * 60)
        dns_result = await dns_enum(target)
        results.append(dns_result)
        
        results.append("\nğŸ“‹ SUBDOMAIN DISCOVERY:")
        results.append("-" * 60)
        subfinder_result = await subfinder_scan(target)
        results.append(subfinder_result)
    
    # Web fingerprinting
    results.append("\nğŸ” WEB FINGERPRINTING:")
    results.append("-" * 60)
    whatweb_result = await whatweb_scan(target, "3")
    results.append(whatweb_result)
    
    # SSL/TLS testing for HTTPS services
    results.append("\nğŸ”’ SSL/TLS ASSESSMENT:")
    results.append("-" * 60)
    ssl_result = await sslscan_scan(target)
    results.append(ssl_result)
    
    results.append("\n" + "=" * 60)
    results.append("âœ… Full reconnaissance completed")
    results.append("=" * 60)
    
    return "\n".join(results)

@mcp.tool()
async def web_audit(target: str = "") -> str:
    """Complete web application security audit combining multiple web testing tools."""
    target = validate_target(target)
    if not target:
        return "âŒ Error: Valid target URL required"
    
    if not target.startswith("http://") and not target.startswith("https://"):
        target = f"http://{target}"
    
    results = []
    results.append("=" * 60)
    results.append("ğŸŒ WEB APPLICATION SECURITY AUDIT")
    results.append("=" * 60)
    
    # Technology fingerprinting
    results.append("\nğŸ” TECHNOLOGY FINGERPRINTING:")
    results.append("-" * 60)
    whatweb_result = await whatweb_scan(target, "3")
    results.append(whatweb_result)
    
    # WAF detection
    results.append("\nğŸ›¡ï¸ WEB APPLICATION FIREWALL DETECTION:")
    results.append("-" * 60)
    waf_result = await wafw00f_scan(target)
    results.append(waf_result)
    
    # HTTP headers analysis
    results.append("\nğŸ“¨ HTTP HEADERS ANALYSIS:")
    results.append("-" * 60)
    headers_result = await web_headers(target)
    results.append(headers_result)
    
    # Nikto vulnerability scan
    results.append("\nğŸ” VULNERABILITY SCAN (Nikto):")
    results.append("-" * 60)
    nikto_result = await nikto_scan(target)
    results.append(nikto_result)
    
    # SSL/TLS check for HTTPS
    if target.startswith("https://"):
        results.append("\nğŸ”’ SSL/TLS CONFIGURATION:")
        results.append("-" * 60)
        hostname = target.replace("https://", "").replace("http://", "").split("/")[0].split(":")[0]
        ssl_result = await sslscan_scan(hostname)
        results.append(ssl_result)
    
    results.append("\n" + "=" * 60)
    results.append("âœ… Web application audit completed")
    results.append("=" * 60)
    
    return "\n".join(results)

@mcp.tool()
async def network_sweep(target: str = "") -> str:
    """Full network discovery and mapping using multiple network reconnaissance tools."""
    target = validate_target(target)
    if not target:
        return "âŒ Error: Valid network range required (e.g., 192.168.1.0/24)"
    
    results = []
    results.append("=" * 60)
    results.append("ğŸŒ NETWORK SWEEP REPORT")
    results.append("=" * 60)
    
    # Host discovery
    results.append("\nğŸ“¡ HOST DISCOVERY (Nmap):")
    results.append("-" * 60)
    nmap_result = await nmap_scan(target)
    results.append(nmap_result)
    
    # NetBIOS scanning
    results.append("\nğŸ’» NETBIOS SCAN:")
    results.append("-" * 60)
    nbtscan_result = await nbtscan_scan(target)
    results.append(nbtscan_result)
    
    results.append("\n" + "=" * 60)
    results.append("âœ… Network sweep completed")
    results.append("=" * 60)
    
    return "\n".join(results)

# === SERVER STARTUP ===

if __name__ == "__main__":
    logger.info("=" * 60)
    logger.info("ğŸ” Starting Kali Linux Penetration Testing MCP Server")
    logger.info("=" * 60)
    logger.warning("âš ï¸  This server provides powerful security testing tools")
    logger.warning("âš ï¸  USE ONLY ON AUTHORIZED TARGETS")
    logger.warning("âš ï¸  Unauthorized testing is ILLEGAL")
    logger.info("=" * 60)
    logger.info("ğŸ“¦ Tools loaded: 42 security assessment tools")
    logger.info("ğŸ—ï¸  Architecture: Docker MCP on ARM64 (Apple Silicon)")
    logger.info("ğŸ”’ Security: Running as non-root user")
    logger.info("=" * 60)
    
    try:
        mcp.run(transport='stdio')
    except Exception as e:
        logger.error(f"âŒ Server error: {e}", exc_info=True)
        sys.exit(1)
